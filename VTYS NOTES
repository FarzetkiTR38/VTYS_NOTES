CREATE DATABASE BTK_SQL_COURSE

USE BTK_SQL_COURSE

CREATE TABLE CUSTOMERS (
    ID INT PRIMARY KEY,
    CUSTOMERNAME NVARCHAR(50) NOT NULL,
    CITY NVARCHAR(30) NOT NULL,
    BIRTHDATE DATE NOT NULL,
    DISTRICT NVARCHAR(30) NOT NULL,
    GENDER CHAR(1) NOT NULL
);

INSERT INTO CUSTOMERS (ID, CUSTOMERNAME, CITY, BIRTHDATE, DISTRICT, GENDER)
VALUES
(1, 'Ã–MER Ã‡OLAKOÄžLU', 'Ä°STANBUL', '1980-12-11', 'ÃœSKÃœDAR', 'E'),
(2, 'AHMET COÅžKUN', 'BURSA', '1990-01-01', 'MUDANYA', 'E'),
(3, 'Ã–ZLEM ATAÅž', 'ANKARA', '1992-04-02', 'Ã‡ANKAYA', 'K'),
(4, 'MUSTAFA KARA', 'Ä°ZMÄ°R', '1984-09-08', 'KARÅžIYAKA', 'E');

SELECT * FROM CUSTOMERS -- hepsini Ã§Ä±ktÄ± alÄ±yor

SELECT ID,CUSTOMERNAME,CITY,BIRTHDATE,DISTRICT FROM CUSTOMERS -- * kullanmadan hepsini Ã§Ä±ktÄ± almak istersek

INSERT INTO CUSTOMERS (ID, CUSTOMERNAME, CITY, BIRTHDATE, DISTRICT, GENDER)
VALUES
--(1,'Ã–MER Ã‡OLAKOÄžLU','Ä°STANBUL','1980-12-11','ÃœSKÃœDAR','E'),
--(2,'AHMET COÅžKUN','BURSA','1990-01-01','MUDANYA','E'),
--(3,'Ã–ZLEM ATAÅž','ANKARA','1992-04-02','Ã‡ANKAYA','K'),
--(4,'MUSTAFA KARA','Ä°ZMÄ°R','1984-09-08','KARÅžIYAKA','E'),
(5,'AYÅžE DEMÄ°R','Ä°STANBUL','1995-06-14','KADIKÃ–Y','K'),
(6,'MEHMET YILMAZ','ANKARA','1988-03-21','KEÃ‡Ä°Ã–REN','E'),
(7,'FATMA ÅžAHÄ°N','BURSA','1993-11-09','NÄ°LÃœFER','K'),
(8,'ALÄ° AKSOY','Ä°ZMÄ°R','1986-07-30','BORNOVA','E'),
(9,'ZEYNEP KAYA','ANTALYA','1997-05-18','MURATPAÅžA','K'),
(10,'HASAN ARSLAN','KONYA','1982-02-10','SELÃ‡UKLU','E'),

(11,'ELÄ°F YÃœKSEL','ANKARA','1994-08-25','ETÄ°MESGUT','K'),
(12,'MURAT POLAT','Ä°STANBUL','1981-04-03','BEÅžÄ°KTAÅž','E'),
(13,'SELÄ°N Ã‡ETÄ°N','Ä°ZMÄ°R','1996-09-12','BALÃ‡OVA','K'),
(14,'EMRE GÃœNEÅž','ADANA','1989-01-19','SEYHAN','E'),
(15,'DÄ°LEK AKIN','MERSÄ°N','1998-10-07','MEZÄ°TLÄ°','K'),
(16,'ONUR KOÃ‡','ESKÄ°ÅžEHÄ°R','1991-12-29','ODUNPAZARI','E'),
(17,'BÃœÅžRA ERDOÄžAN','Ä°STANBUL','1999-03-15','ESENYURT','K'),
(18,'SERKAN AYDIN','SAMSUN','1985-06-05','ATAKUM','E'),
(19,'GÄ°ZEM TOPRAK','TRABZON','1997-11-27','ORTAHÄ°SAR','K'),
(20,'HÃœSEYÄ°N YAVUZ','KAYSERÄ°','1983-05-01','MELÄ°KGAZÄ°','E'),

(21,'MELÄ°SA BULUT','DENÄ°ZLÄ°','1996-02-14','PAMUKKALE','K'),
(22,'VOLKAN ÅžEN','MANÄ°SA','1987-07-09','YUNUSEMRE','E'),
(23,'SEDA KURT','Ä°STANBUL','1992-01-22','BAKIRKÃ–Y','K'),
(24,'CAN Ã–ZTÃœRK','ANKARA','1984-04-18','YENÄ°MAHALLE','E'),
(25,'PINAR DOÄžAN','Ä°ZMÄ°R','1995-09-30','GAZÄ°EMÄ°R','K'),
(26,'KEREM TUNA','MUÄžLA','1990-12-03','MENTEÅžE','E'),
(27,'NAZLI KAPLAN','AYDIN','1998-06-11','EFELER','K'),
(28,'BURAK TEKÄ°N','KOCAELÄ°','1986-08-20','Ä°ZMÄ°T','E'),
(29,'ECE UZUN','Ä°STANBUL','1999-10-16','ATAÅžEHÄ°R','K'),
(30,'TOLGA KILIÃ‡','BALIKESÄ°R','1982-01-05','ALTIEYLÃœL','E'),

(31,'ÅžEYMA AKTAÅž','GAZÄ°ANTEP','1996-04-09','ÅžEHÄ°TKAMÄ°L','K'),
(32,'HALÄ°L DEMÄ°RCÄ°','ÅžANLIURFA','1981-11-11','HALÄ°LÄ°YE','E'),
(33,'Ä°REM AY','Ä°STANBUL','2000-02-02','SARIYER','K'),
(34,'KADÄ°R Ã–ZKAN','ANKARA','1987-06-28','MAMAK','E'),
(35,'NÄ°SA Ã‡AKIR','KAYSERÄ°','1994-09-19','TALAS','K'),
(36,'UÄžUR ÅžENTÃœRK','TEKÄ°RDAÄž','1985-12-07','Ã‡ORLU','E'),
(37,'BETÃœL ASLAN','Ä°ZMÄ°R','1997-03-26','NARLIDERE','K'),
(38,'YUSUF EREN','SAKARYA','1991-08-14','ADAPAZARI','E'),
(39,'SENA GÃ–K','BOLU','1999-01-30','MERKEZ','K'),
(40,'Ä°SMAÄ°L AKAR','YOZGAT','1983-05-22','MERKEZ','E'),

(41,'DENÄ°Z YILDIZ','Ä°STANBUL','1998-07-07','MALTEPE','K'),
(42,'RAMAZAN Ã‡ELÄ°K','KIRIKKALE','1984-10-12','MERKEZ','E'),
(43,'ESRA KÃ–SE','AFYON','1996-02-19','MERKEZ','K'),
(44,'HAKAN SARI','Ä°STANBUL','1982-03-08','PENDÄ°K','E'),
(45,'MERVE ÅžAHÄ°N','ANKARA','1995-06-01','SÄ°NCAN','K'),
(46,'ERHAN BOZ','ANTALYA','1987-11-17','KEPEZ','E'),
(47,'DAMLA AYDIN','Ä°ZMÄ°R','1999-04-04','URLA','K'),
(48,'FURKAN YALÃ‡IN','KONYA','1993-09-23','MERAM','E'),
(49,'TUÄžÃ‡E ER','Ä°STANBUL','1997-12-10','BAYRAMPAÅžA','K'),
(50,'OKAN DURU','EDÄ°RNE','1981-01-28','MERKEZ','E');

SELECT * FROM CUSTOMERS -- hepsini Ã§Ä±ktÄ± alÄ±yor

UPDATE CUSTOMERS 
SET NATION = 'TR', AGE = 35
-- bu ÅŸekilde toplu bir biÃ§imde bÃ¼tÃ¼n herkesin 
-- nation ve age deÄŸerlerini set edebiliyoruz.

SELECT DATEDIFF(YEAR, '1980-12-11', '2020-01-01')
-- 1. tarih ile 2. tarih arasÄ±ndaki yÄ±l farkÄ±nÄ± buluyor.
SELECT DATEDIFF(YEAR, '1980-12-11', GETDATE())
-- 1. tarih ile ÅŸimdiki tarih arasÄ±ndaki yÄ±l farkÄ±nÄ± buluyor.

UPDATE CUSTOMERS
SET NATION = 'TR', AGE = DATEDIFF(YEAR, BIRTHDATE, GETDATE())

--DELETE FROM CUSTOMERS
-- bunu yazarak customers tablosundaki verileri silebiliyoruz. YapmadÄ±m tab2 .d

--TRUNCATE FROM CUSTOMERS
-- bunun deleteden farkÄ± -> delete ile sildiÄŸimiz zaman ID'ler falan kaldÄ±ÄŸÄ± yerden devam ediyor
-- truncate de ise tabloyu ilk oluÅŸturduÄŸu hale getiriyor ID'ler falan 1'den baÅŸlÄ±yor

-- WHERE DE KULLANACAÄžIMIZ BÄ°LMEDÄ°ÄžÄ°M ÅžARTLAR:
-- <>  eÅŸit deÄŸildir
-- between  arasÄ±ndadÄ±r
-- like  ile baÅŸlar, ile biter, iÃ§erir
-- in  iÃ§indedir
-- not like  ile baÅŸlamaz, ile bitmez, iÃ§ermez
-- not in  iÃ§inde deÄŸildir

SELECT * FROM CUSTOMERS
WHERE CUSTOMERNAME = 'ÅžEYMA AKTAÅž'

SELECT * FROM CUSTOMERS
WHERE CITY = 'Ä°ZMÄ°R'
--City izmir olanlarÄ± listeledi

SELECT * FROM CUSTOMERS
WHERE CITY <> 'Ä°ZMÄ°R'
--City izmir olmayanlarÄ± listeledi

SELECT * FROM CUSTOMERS
WHERE NOT CITY = 'Ä°ZMÄ°R'
--City izmir olmayanlarÄ± listeledi

SELECT * FROM CUSTOMERS
WHERE BIRTHDATE > '1990-01-01'
-- doÄŸum tarihi 1990 dan bÃ¼yÃ¼k olanlarÄ± listeledi

SELECT * FROM CUSTOMERS
WHERE BIRTHDATE < '1990-01-01'
-- doÄŸum tarihi 1990 dan kÃ¼Ã§Ã¼k olanlarÄ± listeledi

-- >= ve <= de kullanabiliyoruz Ã¶rneÄŸe gerek yok basit.

SELECT * FROM CUSTOMERS
WHERE BIRTHDATE BETWEEN '19900101' AND '19931231'
-- doÄŸum tarihi 1990 Ä°LE 1993'Ã¼n sonuna kadar olanlarÄ± listeledi
-- 19900101 ile 1990-01-01 aynÄ± ÅŸeyler.

SELECT * FROM CUSTOMERS
WHERE AGE BETWEEN '30' AND '35'
-- yaÅŸÄ± 30 ile 35 arasÄ±ndakileri listeledi

SELECT * FROM CUSTOMERS
WHERE CUSTOMERNAME LIKE 'ALÄ°%'
-- adÄ± ali ile baÅŸlayanlarÄ± listeledi

SELECT * FROM CUSTOMERS
WHERE CUSTOMERNAME LIKE '%Ã‡ELÄ°K'
-- adÄ± Ã‡ELÄ°K ile bitenleri listeledi

SELECT * FROM CUSTOMERS
WHERE CUSTOMERNAME LIKE '%AL%'
-- adÄ±nda AL geÃ§enleri listeledi

SELECT * FROM CUSTOMERS
WHERE CUSTOMERNAME NOT LIKE '%AL%'
-- adÄ±nda AL geÃ§meyenleri listeledi

SELECT * FROM CUSTOMERS
WHERE CITY IN ('Ä°STANBUL', 'ANKARA')
-- city istanbul ve ankara olanlarÄ± listeledi

UPDATE CUSTOMERS SET GENDER = 'ERKEK' WHERE GENDER = 'E'
UPDATE CUSTOMERS SET GENDER = 'KADIN' WHERE GENDER = 'K'
-- GENDER'i K olanlarÄ± KADIN olarak deÄŸiÅŸtirdik
-- GENDER'i E olanlarÄ± ERKEK olarak deÄŸiÅŸtirdik

-- AND & OR OPERATÃ–RLERÄ°
SELECT * FROM CUSTOMERS
WHERE CITY = 'Ä°STANBUL' AND DISTRICT = 'ESENYURT' OR DISTRICT = 'BAKIRKÃ–Y'
-- city istanbul olan ve district esenyurt ya da bakÄ±rkÃ¶y olanlarÄ± listeledi

SELECT * FROM CUSTOMERS
WHERE GENDER = 'ERKEK' AND CITY = 'Ä°ZMÄ°R'
-- hem erkek olan hem de izmirli olanlarÄ± listeledik.

-- DISTINCT 
SELECT CITY FROM CUSTOMERS -- bu haliyle bÃ¼tÃ¼n verilerin city deÄŸerini Ã§Ä±ktÄ± alÄ±r.
SELECT DISTINCT CITY FROM CUSTOMERS 
-- ama DISTINCT kullanÄ±rsak her veriyi 1 kere Ã§Ä±ktÄ± alÄ±yor.

SELECT GENDER FROM CUSTOMERS 
-- tÃ¼m verilerin sahip olduÄŸu cinsiyetleri listeledi 50 veri yani
SELECT DISTINCT GENDER FROM CUSTOMERS 
-- her veriyi 1 kere sayÄ±yor yani 2 cinsiyet var 2 Ã§Ä±ktÄ±mÄ±z oldu.

SELECT DISTINCT AGE FROM CUSTOMERS
-- benzer Ã¶rnek: her yaÅŸÄ± 1 kere Ã§Ä±ktÄ± alÄ±yor sadece.

-- Bundan Ã¶ncekiler sorguyla alakalÄ±ydÄ± ÅŸimdi sorguda sÄ±ralamayÄ± yapacaÄŸÄ±
-- ORDER BY

-- ASC -> A'DAN Z'YE kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe
-- DESC -> Z'DEN A'YA bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe

SELECT * FROM CUSTOMERS 
ORDER BY ID ASC
-- aynÄ± sÄ±ralamayÄ± yapacak

SELECT * FROM CUSTOMERS 
ORDER BY ID DESC
-- ÅŸimdi ID'yi bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe doÄŸru sÄ±raladÄ±

SELECT * FROM CUSTOMERS 
ORDER BY CUSTOMERNAME ASC
-- isimleri kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe (a'dan z'ye) doÄŸru sÄ±raladÄ±

SELECT * FROM CUSTOMERS 
ORDER BY CUSTOMERNAME DESC
-- isimleri bÃ¼yÃ¼ktne kÃ¼Ã§Ã¼ÄŸe (z'den a'ya) doÄŸru sÄ±raladÄ±

SELECT * FROM CUSTOMERS 
ORDER BY BIRTHDATE ASC
-- doÄŸum tarihlerini kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±raladÄ±

SELECT * FROM CUSTOMERS 
ORDER BY AGE ASC
-- yaÅŸlarÄ± kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe doÄŸru sÄ±raladÄ±

SELECT * FROM CUSTOMERS 
ORDER BY CITY,CUSTOMERNAME ASC
--Ã¶nce ÅŸehiri kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe (a'dan z'ye) sÄ±raladÄ±ktan sonra 
--aynÄ± olanlarÄ±n da isimlerini kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe (a'dan z'ye) sÄ±raladÄ±.

-- burada 2 sÄ±ralama olduÄŸundan ÅŸu ÅŸekilde aslÄ±nda:
SELECT * FROM CUSTOMERS 
ORDER BY CITY ASC,CUSTOMERNAME ASC
-- istersen bunu birisi kÃ¼Ã§Ã¼kten bÃ¼yÃ¼ÄŸe birisi bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe ÅŸeklinde de
-- deÄŸiÅŸtirebiliriz ÅŸu ÅŸekilde: 
SELECT * FROM CUSTOMERS 
ORDER BY CITY ASC,CUSTOMERNAME DESC
-- gibi.

-- BURAYA Ã‡ALIÅžMAYA GEREK YOK AMA EXTRA BÄ°LGÄ°:
SELECT * FROM CUSTOMERS 
ORDER BY 1

SELECT * FROM CUSTOMERS 
ORDER BY 2

SELECT * FROM CUSTOMERS 
ORDER BY 3
-- 1 yazdÄ±ÄŸÄ±mÄ±zda 1. kolon -> ID'ye gÃ¶re sÄ±ralÄ±yor. 
-- 2 yazdÄ±ÄŸÄ±mÄ±zda 2. kolon -> CUSTOMERNAME'ye gÃ¶re sÄ±ralÄ±yor.
-- 3 yazdÄ±ÄŸÄ±mÄ±zda 3. kolon -> CITY'ye gÃ¶re sÄ±ralÄ±yor .. bla bla gider..

-- TOP
SELECT TOP 10 * FROM CUSTOMERS
-- TOP ile kaÃ§ adet veriyi listeleyeceÄŸimizi belirtiyoruz misal 10 yazdÄ±ÄŸÄ±m iÃ§in
-- 10 adet veriyi listeledi.
-- atÄ±yorum 100.000 verimiz olan bir tabloda 100.000 veri listelemek yerine 
-- belirli sayÄ±da veriyi listelemk isteyebiliriz bunun iÃ§in top kullanÄ±yoruz.
SELECT TOP 100 PERCENT * FROM CUSTOMERS
-- PERCENT ile de %'lik belirtiyoruz. TOP 100 PERCENT yazdÄ±ÄŸÄ±mÄ±zda tablonun tamamÄ±nÄ±
-- yani %100'Ã¼nÃ¼ listeler.
SELECT TOP 20 PERCENT * FROM CUSTOMERS
-- ÅŸimdi TOP 20 PERCENT yazdÄ±ÄŸÄ±mÄ±zda ise tablonun %20'si yani 50 verimiz var %20'si 10 veri listeler.

-- AGGREGATE FUNCTIONS (SUM MIN MAX AVG COUNT)
-- SUM toplam
-- MIN en dÃ¼ÅŸÃ¼k olan
-- MAX en yÃ¼ksek olan
-- AVG ortalamasÄ±
-- COUNT sayÄ±sÄ±
-- biliyoruz zaten de s.et :d

SELECT COUNT(*) FROM CUSTOMERS
-- satÄ±r sayÄ±sÄ±nÄ± veriyor -> 50

SELECT MIN(AGE), MAX(AGE), COUNT(*) FROM CUSTOMERS
-- listemizdeki en kÃ¼Ã§Ã¼k yaÅŸo, en bÃ¼yÃ¼k yaÅŸÄ± ve listedeki eleman sayÄ±sÄ±nÄ± Ã§Ä±ktÄ± aldÄ±k.
SELECT SUM(AGE) FROM CUSTOMERS
-- listemizdeki yaÅŸlarÄ±n toplamÄ±nÄ± aldÄ±k yani 50 tane yaÅŸÄ± topladÄ±k.
SELECT AVG(AGE) FROM CUSTOMERS
-- listedeki yaÅŸlarÄ±n ortalamasÄ±nÄ± Ã§Ä±ktÄ± aldÄ±k.

-- AGGREGATE FUNCTIONS unun GROUP BY 

SELECT MIN(AGE), MAX(AGE), COUNT(*), SUM(AGE), AVG(AGE) FROM CUSTOMERS
-- eÄŸer ki buna CITY eklersek hata veriyor GROUP BY da eklememiz gerekiyor.

SELECT CITY, 
MIN(AGE), MAX(AGE), COUNT(*), SUM(AGE), AVG(AGE) FROM CUSTOMERS 
GROUP BY CITY

-- sÃ¼tunlara isim vermek iÃ§in de 
-- AS SÃœTUNADI   kullanÄ±yoruz:

SELECT CITY, 
MIN(AGE) AS MINAGE, MAX(AGE) AS MAXAGE, COUNT(*) COUNTAMOUNT,
SUM(AGE) AS SUMAGE, AVG(AGE) AS AVGAGE FROM CUSTOMERS 
GROUP BY CITY 

-- bunu da en kÃ¼Ã§Ã¼k yaÅŸa gÃ¶re sÄ±ralarsam:

SELECT CITY, 
MIN(AGE) AS MINAGE, MAX(AGE) AS MAXAGE, COUNT(*) COUNTAMOUNT,
SUM(AGE) AS SUMAGE, AVG(AGE) AS AVGAGE FROM CUSTOMERS 
GROUP BY CITY ORDER BY MIN(AGE) 


SELECT TOP 10 CUSTOMERNAME ,
MIN(AGE) AS MINAGE FROM CUSTOMERS GROUP BY CUSTOMERNAME ORDER BY MIN(AGE)
-- yaÅŸÄ± en kÃ¼Ã§Ã¼k olan Ã¼yelerin isimlerini listeledik ilk 10 veriyi Ã§ektik.

SELECT * FROM CUSTOMERS

SELECT CONVERT(DATE, '1980-12-11 04:15:10.000') -- sadece tarih
SELECT CONVERT(TIME, '1980-12-11 04:15:10.000') -- sadece saat
SELECT CONVERT(DATETIME, '1980-12-11 04:15:10.000') -- hem tarih hem saat


SELECT CITY,SUM(AGE) AS SUMAGE
FROM CUSTOMERS WHERE CITY = 'Ä°STANBUL'
GROUP BY CITY
-- Ä°STANBUL dakilerin yaÅŸlarÄ±nÄ±n toplamÄ±nÄ± Ã§Ä±ktÄ± aldÄ±k

SELECT CITY,SUM(AGE) AS SUMAGE
FROM CUSTOMERS
GROUP BY CITY
-- her ÅŸehirde olanlarÄ±n yaÅŸlarÄ±nÄ±n toplamÄ±nÄ± listeledik

SELECT CITY,SUM(AGE) AS SUMAGE
FROM CUSTOMERS
GROUP BY CITY 
ORDER BY SUMAGE DESC
-- Ä°STANBUL dakilerin yaÅŸlarÄ±nÄ±n toplamÄ±nÄ± bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe doÄŸru listeledik


SELECT DATEPART(MONTH, '2020-05-28') AS ISTEDIGIMIZ_AY
SELECT DATEPART(YEAR, '1999-12-05') AS ISTEDIGIMIZ_YIL
SELECT DATEPART(DAY, '2025-12-23') AS ISTEDIGIMIZ_GUN
-- datepart ile istediÄŸimiz tarihden istediÄŸimiz kÄ±smÄ± Ã§ekebiliyoruz.

SELECT CUSTOMERNAME, BIRTHDATE, DATEPART(MONTH, BIRTHDATE) AS ISTEDIGIMIZ_AY 
FROM CUSTOMERS
ORDER BY ISTEDIGIMIZ_AY
-- herkesin doÄŸum tarihinin ay sÄ±ralamasÄ±nÄ± yaptÄ±rdÄ±k


-- Devam etmek iÃ§in bize CUSTOMERS tablosu ile iliÅŸkili bir tablo lazÄ±mdÄ±:

CREATE TABLE ORDERS (
    ORDER_ID INT PRIMARY KEY,
    CUSTOMER_ID INT NOT NULL,
    ORDER_DATE DATE NOT NULL,
    TOTAL_AMOUNT DECIMAL(10,2) NOT NULL,

    CONSTRAINT FK_ORDERS_CUSTOMERS
        FOREIGN KEY (CUSTOMER_ID)
        REFERENCES CUSTOMERS(ID)
);

INSERT INTO ORDERS (ORDER_ID, CUSTOMER_ID, ORDER_DATE, TOTAL_AMOUNT)
VALUES
(1001, 1,  '2024-01-10', 1250.00),
(1002, 1,  '2024-03-15',  850.50),
(1003, 2,  '2024-02-05',  420.75),
(1004, 3,  '2024-01-20',  990.00),
(1005, 3,  '2024-04-02',  310.25),
(1006, 4,  '2024-02-18',  670.00),
(1007, 5,  '2024-03-01', 1450.90),
(1008, 6,  '2024-01-25',  560.00),
(1009, 6,  '2024-03-30',  780.40),
(1010, 7,  '2024-02-14',  320.00),
(1011, 8,  '2024-04-10', 1100.00),
(1012, 9,  '2024-01-08',  250.00),
(1013, 10, '2024-02-27',  890.75),
(1014, 11, '2024-03-12',  460.00),
(1015, 12, '2024-01-19', 1320.60),
(1016, 13, '2024-04-05',  510.00),
(1017, 14, '2024-02-09',  740.30),
(1018, 15, '2024-03-22',  295.00),
(1019, 16, '2024-01-30',  980.00),
(1020, 17, '2024-04-14',  410.45),
(1021, 18, '2024-02-03',  860.00),
(1022, 19, '2024-03-18',  330.00),
(1023, 20, '2024-01-11', 1200.00);

-- !! NOT !! CONSTRAINT Ã¶ÄŸren
-- !! NOT !! HAVING Ã¶ÄŸren
-- !! NOT !! %[A-Z]% falan olayÄ± var onu da Ã¶ÄŸrenmem gerek.



SELECT * FROM CUSTOMERS WHERE ID=1

SELECT * FROM ORDERS WHERE CUSTOMER_ID=1

SELECT CUSTOMERS.* , ORDERS.TOTAL_AMOUNT FROM
CUSTOMERS,ORDERS
WHERE ORDERS.CUSTOMER_ID = CUSTOMERS.ID
-- ORDERS.CUSTOMER_ID ile CUSTOMERS.ID aynÄ± olan verilerin
-- CUSTOMERS tablosunu ve ORDERS.TOTAL_AMOUNT sÃ¼tunun listeledik.

SELECT CUSTOMERS.* , ORDERS.TOTAL_AMOUNT FROM
CUSTOMERS,ORDERS
WHERE ORDERS.CUSTOMER_ID = CUSTOMERS.ID
AND ID=3
-- yukardakine extra olarak sadece ID'si 3 olan Ã–ZLEM ATAÅž'Ä±n verilerini listeledik.

SELECT CUSTOMERS.CUSTOMERNAME, CUSTOMERS.CITY, CUSTOMERS.DISTRICT, ORDERS.TOTAL_AMOUNT FROM
CUSTOMERS,ORDERS
WHERE ORDERS.CUSTOMER_ID = CUSTOMERS.ID
AND ID=3
-- CUSTOMERS tablosunun tamamÄ± yerine ondan da istediÄŸimiz sÃ¼tunlarÄ± Ã§Ä±ktÄ± alabiliyoruz bu ÅŸekilde.

SELECT C.CUSTOMERNAME, C.CITY, C.DISTRICT, O.TOTAL_AMOUNT FROM
CUSTOMERS C,ORDERS O
WHERE O.CUSTOMER_ID = C.ID
AND ID=3
-- Tablolara yeni isim veya kÄ±saltma verebiliyoruz bu sayede 
-- her seferinde tablonun adÄ±nÄ± yazmak yerine
-- eklediÄŸimiz kÄ±saltma veya yeni adÄ±nÄ± yazabiliyoruz.
-- buna alias deniyor.
-- bunu sadece tablo adÄ±na deÄŸil sÃ¼tunlara da ekleyebiliyoruz
-- AS operatÃ¶rÃ¼ ile ekliyoruz yazmasak da kabul ediyor
-- listelediÄŸimizde sÃ¼tunun yeni adÄ± gÃ¶zÃ¼kÃ¼yor:
SELECT C.CUSTOMERNAME ADSOYAD, 
C.CITY SEHIR, 
C.DISTRICT ILCE, 
O.TOTAL_AMOUNT TOPLAMMIKTAR 
FROM
CUSTOMERS C,ORDERS O
WHERE O.CUSTOMER_ID = C.ID
AND ID=3

-- JOIN --
-- Eski sistem ile yaptÄ±ÄŸÄ±mÄ±zÄ± join ile yapacaÄŸÄ±z daha iÅŸlevsel
-- Ã–RNEK kullanÄ±m ÅŸekli:
-- FROM TABLO1 A
-- JOIN TABLO2 B ON A.PK_KOLON = B.FK_KOLON

-- JOIN tÃ¼rleri:
-- INNER JOIN -- tablolarÄ± kÃ¼me kabul edersek, kesiÅŸimine de INNER JOIN diyebiliriz.
-- LEFT (OUTER) JOIN -- yine aynÄ± ÅŸekilde tablolarÄ± kÃ¼me kabul edersek
-- soldaki kÃ¼menin tamamÄ±nÄ± + olarak kesiÅŸim kÃ¼mesini alÄ±yoruz.
-- soldaki veriyi aldÄ±ÄŸÄ±mÄ±zda karÅŸÄ±lÄ±ÄŸÄ± yoksa saÄŸ tarafÄ± boÅŸ da olsa alÄ±yoruz.
-- RIGHT (OUTER) JOIN -- yine aynÄ± ÅŸekilde tablolarÄ± kÃ¼me kabul edersek
-- saÄŸdaki kÃ¼menin tamamÄ± + olarak kesiÅŸim kÃ¼mesini alÄ±yoruz.
-- saÄŸdaki veriyi aldÄ±ÄŸÄ±mÄ±zda karÅŸÄ±lÄ±ÄŸÄ± yoksa sol tarafÄ± boÅŸ da olsa alÄ±yoruz.
-- FULL JOIN -- yine aynÄ± ÅŸekilde tablolarÄ± kÃ¼me kabul edersek
-- birleÅŸim kÃ¼mesini alÄ±yoruz.
-- saÄŸdaki elemanÄ±n karÅŸÄ±lÄ±ÄŸÄ± yoksa sol tarafÄ± boÅŸ ÅŸekilde alÄ±yoruz.
-- soldaki elemanÄ±n karÅŸÄ±lÄ±ÄŸÄ± yoksa saÄŸ tarafÄ± boÅŸ ÅŸekilde alÄ±yoruz.

-- Ã¶rnek tablo ve verilere ihtiyaÃ§ var ama mantÄ±ÄŸÄ±nÄ± Ã§Ã¶zdÃ¼m
-- FROM TABLO1 A
-- JOIN TABLO2 B ON A.PK_KOLON = B.FK_KOLON
-- buradaki JOIN kÄ±smÄ±nÄ± istediÄŸimiz tÃ¼re gÃ¶re deÄŸiÅŸtiriyoruz
-- JOIN, INNER JOOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN

SELECT * FROM CUSTOMERS
SELECT * FROM ORDERS

-- Åžimdi inner joinler iÃ§in 2 ayrÄ± tablo oluÅŸturacaÄŸÄ±m test ve kodlar iÃ§in

CREATE TABLE Bolumler (
    BolumID INT PRIMARY KEY,
    BolumAdi VARCHAR(50)
);

INSERT INTO Bolumler (BolumID, BolumAdi) VALUES
(1, 'Bilgisayar MÃ¼hendisliÄŸi'),
(2, 'Elektrik Elektronik MÃ¼hendisliÄŸi'),
(3, 'Makine MÃ¼hendisliÄŸi'),
(4, 'Mekatronik MÃ¼hendisliÄŸi'),
(5, 'Ä°nÅŸaat MÃ¼hendisliÄŸi' );

SELECT * FROM Bolumler;



CREATE TABLE Ogrenciler (
    OgrenciID INT PRIMARY KEY,
    Ad VARCHAR(30),
    Soyad VARCHAR(30),
    BolumID INT,
    FOREIGN KEY (BolumID) REFERENCES Bolumler(BolumID)
);

INSERT INTO Ogrenciler (OgrenciID, Ad, Soyad, BolumID) VALUES
(101, 'Ali', 'YÄ±lmaz', 1),
(102, 'AyÅŸe', 'Demir', 2),
(103, 'Mehmet', 'Kaya', 1),
(104, 'Zeynep', 'Ã‡elik', 3),
(105, 'Ahmet', 'KoÃ§', NULL), -- BÃ¶lÃ¼mÃ¼ yok
(106, 'Esat Oktay', 'YÄ±ldÄ±ran', 5); 

SELECT * FROM Ogrenciler

SELECT 
    O.Ad,
    O.Soyad,
    B.BolumAdi
FROM Ogrenciler O
INNER JOIN Bolumler B
    ON O.BolumID = B.BolumID;

-- bÃ¶lÃ¼mÃ¼ olmadÄ±ÄŸÄ± iÃ§in Ahmet KoÃ§'u yazmadÄ±
-- ama inner join yerine LeftJoin ya da RightJoin idi hangisi olduÄŸunu hatÄ±rlamÄ±yorum :D 
-- ama kullanÄ±rsak deÄŸiÅŸtirebiliriz

SELECT 
    O.Ad,
    O.Soyad,
    B.BolumAdi
FROM Ogrenciler O
Left JOIN Bolumler B
    ON O.BolumID = B.BolumID;

SELECT 
    O.Ad,
    O.Soyad,
    B.BolumAdi
FROM Ogrenciler O
Right JOIN Bolumler B
    ON O.BolumID = B.BolumID;

SELECT 
    O.Ad,
    O.Soyad,
    B.BolumAdi
FROM Ogrenciler O
Full JOIN Bolumler B
    ON O.BolumID = B.BolumID;

--- BURADAN SONRASI DA BTK DA OLMAYAN HOCANIN Ä°ÅžLEDÄ°ÄžÄ° KISIMLAR ---
--- VIEW & KISITLAMALAR & TRIGER & WHILE & ... ---

CREATE VIEW viewtable1 AS 
SELECT Ad, Soyad, BolumID
FROM Ogrenciler
-- Ad Soyad BolumId'yi Ogrenciler tablosundan aldÄ± 
-- ve yeni bir tablo oluÅŸturduk adÄ± viewtable1
-- onun elemanlarÄ±nÄ± bu yeni tabloya ekledik.

CREATE VIEW viewtable2 AS 
SELECT Ad, Soyad, BolumAdi
FROM Ogrenciler, Bolumler
-- Burada BolumAdi var ve bu BolumAdi baÅŸka bir tabloda 
-- o yÃ¼zden o tabloyu da ekledik From'a 
-- ama o zaman da ÅŸu ÅŸekilde oluyor Ad Soyad Ogrenciler tablosundan geliyor
-- BolumAdi Bolumler tablosundan geliyor
-- Kartezyen Ã§arpÄ±m yapÄ±yor :d birinde 5 veri var diÄŸerinde 5 veri var 25 verimiz oluyor 
-- Ã§Ã¼nkÃ¼ eÅŸleÅŸen veri yok otomatik hepsiyle hepsini kombine ediyor 5x5 den 25 verimiz oluÅŸuyor.

CREATE VIEW viewtable3 AS 
SELECT Ad, Soyad, BolumAdi
FROM Ogrenciler, Bolumler
Where Bolumler.BolumID = Ogrenciler.BolumID
-- burada ÅŸart olarak Bolumler.BolumID = Ogrenciler.BolumID 
-- dediÄŸimizde her veriye ait olan bÃ¶lÃ¼mÃ¼ atamÄ±ÅŸ oluyoruz hmh :d

SELECT * FROM Ogrenciler
SELECT * FROM Bolumler
SELECT * FROM viewtable1
SELECT * FROM viewtable2
SELECT * FROM viewtable3

CREATE TABLE ConstraintTable(
    Yas int Check(Yas > 18)
);

Insert into ConstraintTable(Yas) Values
(21),
-- (17), hata verir Ã§Ã¼nkÃ¼ ÅŸartÄ± karÅŸÄ±lamÄ±yor.
(19);

Select * From ConstraintTable

CREATE TABLE ConstraintTable2(
    Yas int Check(Yas > 18) Default 19
);

Insert into ConstraintTable2(Yas) Values
(21),
-- (17), hata verir Ã§Ã¼nkÃ¼ ÅŸartÄ± karÅŸÄ±lamÄ±yor.
(19),
(DEFAULT); -- DEFAULT'u 19 verdik eÄŸer deÄŸer vermeyip DEFAULT dersek atadÄ±ÄŸÄ±mÄ±z 19 deÄŸerini alÄ±yor.

Select * From ConstraintTable2

CREATE TABLE Ogrenciler2 (
    OgrenciID INT PRIMARY KEY,                  -- PK
    TCNo CHAR(11) NOT NULL UNIQUE,               -- UNIQUE + NOT NULL
    Ad VARCHAR(30) NOT NULL,                     -- NOT NULL
    Soyad VARCHAR(30) NOT NULL,                  -- NOT NULL
    Yas INT CHECK (Yas BETWEEN 18 AND 35),        -- CHECK
    Email VARCHAR(50) UNIQUE,                    -- UNIQUE
    KayitTarihi DATE DEFAULT GETDATE(),           -- DEFAULT
    BolumID INT,                                 -- FK
    CONSTRAINT FK_Ogrenci_Bolum
        FOREIGN KEY (BolumID)
        REFERENCES Bolumler(BolumID)
);

-- buradaki anlamadÄ±ÄŸÄ±m tek yer:
    --CONSTRAINT FK_Ogrenci_Bolum
    --    FOREIGN KEY (BolumID)
    --    REFERENCES Bolumler(BolumID)
-- onu aÃ§Ä±klayacaÄŸÄ±m: 
--Bu kodun anlamÄ± ÅŸu cÃ¼mledir ðŸ‘‡
--â€œOgrenciler tablosundaki BolumID, Bolumler tablosundaki BolumID deÄŸerlerinden biri olmak zorundadÄ±r.â€
INSERT INTO Ogrenciler2 VALUES
(101, '11111111111', 'Ali', 'YÄ±lmaz', 21, 'ali@uni.edu', DEFAULT, 1);
-- sorunsuz veri giriÅŸi yapabildik her ÅŸartÄ± karÅŸÄ±lÄ±yor.
-- sadece constraint kÄ±smÄ±nÄ± ele alacaÄŸÄ±m:
SELECT * FROM Bolumler
-- burada 5 tane bÃ¶lÃ¼mÃ¼m var ve ID'ler 1 2 3 4 5 
-- ÅŸimdi ben ID'yi 5'den bÃ¼yÃ¼k girersem bu constraint den Ã¶tÃ¼rÃ¼
-- hata oluÅŸacak ve veri giriÅŸine izin vermeyecek:
INSERT INTO Ogrenciler2 VALUES
(102, '22222222222', 'AyÅŸe', 'Demir', 22, 'ayse@uni.edu', DEFAULT, 6)
-- hata verdi ID 5'e kadar atanabilir



CREATE TABLE Ogrenciler3 (
    OgrenciID INT PRIMARY KEY,
    Ad VARCHAR(30),
    Soyad VARCHAR(30),
    Yas INT
);

CREATE TABLE OgrenciLog3 (
    LogID INT IDENTITY PRIMARY KEY,
    OgrenciID INT,
    IslemTipi VARCHAR(10),
    IslemTarihi DATETIME DEFAULT GETDATE()
);

-- inserted â†’ eklenen yeni kayÄ±t(lar)

-- INSERT TRIGGER

CREATE TRIGGER trg_Ogrenci_Insert
ON Ogrenciler3
AFTER INSERT
AS
BEGIN
    INSERT INTO OgrenciLog3 (OgrenciID, IslemTipi)
    SELECT OgrenciID, 'INSERT'
    FROM inserted;
END;

-- burada bir triger oluÅŸturduk adÄ± trg_Ogrenci_Insert 
-- Ogrenciler3 tablosu Ã¼zerinden tetikleyeceÄŸiz
-- AFTER INSERT  -> ekledikten sonra gerÃ§ekleÅŸecek demek
-- bu triger gerÃ§ekleÅŸtiÄŸinde OgrenciLog3 tablosuna
-- log bÄ±rakÄ±yoruz.

INSERT INTO Ogrenciler3 VALUES (1, 'Ali', 'YÄ±lmaz', 21);

SELECT * FROM OgrenciLog3

---

--deleted â†’ eski kayÄ±t
--inserted â†’ yeni kayÄ±t

-- UPDATE TRIGGER


CREATE TRIGGER trg_Ogrenci_Update
ON Ogrenciler3
AFTER UPDATE
AS
BEGIN
    INSERT INTO OgrenciLog3 (OgrenciID, IslemTipi)
    SELECT OgrenciID, 'UPDATE'
    FROM inserted;
END;

UPDATE Ogrenciler3
SET Yas = 22
WHERE OgrenciID = 1;

SELECT * FROM OgrenciLog3

----

--deleted â†’ silinen kayÄ±t

-- DELETE TRIGGER

CREATE TRIGGER trg_Ogrenci_Delete
ON Ogrenciler3
AFTER DELETE
AS
BEGIN
    INSERT INTO OgrenciLog3 (OgrenciID, IslemTipi)
    SELECT OgrenciID, 'DELETE'
    FROM deleted;
END;

DELETE FROM Ogrenciler3
WHERE OgrenciID = 1;

SELECT * FROM OgrenciLog3

--

CREATE TRIGGER trg_SilmeEngelle
ON Ogrenciler3
INSTEAD OF DELETE
AS
BEGIN
    PRINT 'Silme yasak!';
END;

-- Bu triger de INSTEAD OF DELETE kullanarak
-- Silme iÅŸlemi gerÃ§ekleÅŸtireceÄŸi zaman belirttiÄŸimiz iÅŸlemi gerÃ§ekleÅŸtiriyor.
-- Yani silmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±zda PRINT 'Silme yasak!' Ã§alÄ±ÅŸÄ±yor ve silme Ã§alÄ±ÅŸmÄ±yor.



SELECT * FROM OgrenciLog3
SELECT * FROM Ogrenciler3

INSERT INTO Ogrenciler3 VALUES (2, 'Ahmet', 'Ã–lmez', 23);

DELETE FROM Ogrenciler3 WHERE OgrenciID = 2
-- Silmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±zda Silme yasak! uyarÄ±sÄ± veriliyor ve silmiyor.

SELECT * FROM OgrenciLog3
SELECT * FROM Ogrenciler3

-- WHILE

--------------

DECLARE @toplam int
DECLARE @sayac int

Select @toplam = 0
Select @sayac = 1

While (@sayac < 5)
BEGIN
    SELECT @toplam = @toplam + 5
    SELECT @sayac = @sayac + 1

Print 'toplam : '
Print @toplam
END

Print 'sayac: ' 
Print @sayac

-----------------

DECLARE @toplam int
DECLARE @sayac int

Select @toplam = 0
Select @sayac = 1


While (@sayac < 10)
BEGIN
    SELECT @toplam = @toplam + 5
    SELECT @sayac = @sayac + 1
    IF @sayac = 3
    BEGIN
        Print 'SayaÃ§ 3 oldu'
        BREAK
    END
END

Print 'toplam : '
Print @toplam

Print 'sayac: ' 
Print @sayac

---

DECLARE @toplam int
DECLARE @sayac int

Select @toplam = 0
Select @sayac = 0


While (@sayac < 5)
BEGIN
    SELECT @toplam = @toplam + 5
    SELECT @sayac = @sayac + 1
    IF @sayac = 3 
    BEGIN
        CONTINUE
    END
    Print 'SayaÃ§ : '
    Print @sayac
END

Print 'toplam : '
Print @toplam
